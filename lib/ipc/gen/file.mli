(** Automatically generated by the FlatBuffers compiler

    root type: org.apache.arrow.flatbuf.Footer (//File.fbs) flatc version:
    23.3.3 *)

module Rt : Flatbuffers.Runtime.Intf

module rec Org : sig
  module rec Apache : sig
    module rec Arrow : sig
      module rec Flatbuf : sig
        (* Enum org.apache.arrow.flatbuf.UnionMode (//Schema.fbs) *)
        module rec UnionMode : sig
          type t = private Rt.Short.t

          val sparse : t
          val dense : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** ----------------------------------------------------------------------
            Top-level Type value, enabling extensible type-specific metadata. We
            can add new logical types to Type without breaking backwards
            compatibility

            Union org.apache.arrow.flatbuf.Type (//Schema.fbs) *)
        and Type : sig
          type t = private Rt.UType.t

          val none : t
          val null : t
          val int : t
          val floating_point : t
          val binary : t
          val utf8 : t
          val bool : t
          val decimal : t
          val date : t
          val time : t
          val timestamp : t
          val interval : t
          val list : t
          val struct_ : t
          val union : t
          val fixed_size_binary : t
          val fixed_size_list : t
          val map : t
          val duration : t
          val large_binary : t
          val large_utf8 : t
          val large_list : t
          val run_end_encoded : t
          val binary_view : t
          val utf8_view : t
          val list_view : t
          val large_list_view : t
          val to_string : t -> string
        end

        (* Enum org.apache.arrow.flatbuf.TimeUnit (//Schema.fbs) *)
        and TimeUnit : sig
          type t = private Rt.Short.t

          val second : t
          val millisecond : t
          val microsecond : t
          val nanosecond : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.Precision (//Schema.fbs) *)
        and Precision : sig
          type t = private Rt.Short.t

          val half : t
          val single : t
          val double : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.MetadataVersion (//Schema.fbs) *)
        and MetadataVersion : sig
          type t = private Rt.Short.t

          val v1 : t
          (** 0.1.0 (October 2016). *)

          val v2 : t
          (** 0.2.0 (February 2017). Non-backwards compatible with V1. *)

          val v3 : t
          (** 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible
              with V2. *)

          val v4 : t
          (** >= 0.8.0 (December 2017). Non-backwards compatible with V3. *)

          val v5 : t
          (** >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can
              read V4 metadata and IPC messages). Implementations are
              recommended to provide a V4 compatibility mode with V5 format
              changes disabled. Incompatible changes between V4 and V5: - Union
              buffer layout has changed. In V5, Unions don't have a validity
              bitmap buffer. *)

          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.IntervalUnit (//Schema.fbs) *)
        and IntervalUnit : sig
          type t = private Rt.Short.t

          val year_month : t
          val day_time : t
          val month_day_nano : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** Represents Arrow Features that might not have full support within
            implementations. This is intended to be used in two scenarios: 1. A
            mechanism for readers of Arrow Streams and files to understand that
            the stream or file makes use of a feature that isn't supported or
            unknown to the implementation (and therefore can meet the Arrow
            forward compatibility guarantees). 2. A means of negotiating between
            a client and server what features a stream is allowed to use. The
            enums values here are intended to represent higher level features,
            additional details may be negotiated with key-value pairs specific
            to the protocol. Enums added to this list should be assigned
            power-of-two values to facilitate exchanging and comparing bitmaps
            for supported features.

            Enum org.apache.arrow.flatbuf.Feature (//Schema.fbs) *)
        and Feature : sig
          type t = private Rt.Long.t

          val unused : t
          (** Needed to make flatbuffers happy. *)

          val dictionary_replacement : t
          (** The stream makes use of multiple full dictionaries with the same
              ID and assumes clients implement dictionary replacement correctly.
          *)

          val compressed_body : t
          (** The stream makes use of compressed bodies as described in
              Message.fbs. *)

          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** ----------------------------------------------------------------------
            Endianness of the platform producing the data

            Enum org.apache.arrow.flatbuf.Endianness (//Schema.fbs) *)
        and Endianness : sig
          type t = private Rt.Short.t

          val little : t
          val big : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** ----------------------------------------------------------------------
            Dictionary encoding metadata Maintained for forwards compatibility,
            in the future Dictionaries might be explicit maps between integers
            and values allowing for non-contiguous index values

            Enum org.apache.arrow.flatbuf.DictionaryKind (//Schema.fbs) *)
        and DictionaryKind : sig
          type t = private Rt.Short.t

          val dense_array : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.DateUnit (//Schema.fbs) *)
        and DateUnit : sig
          type t = private Rt.Short.t

          val day : t
          val millisecond : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** Logically the same as Utf8, but the internal representation uses a
            view struct that contains the string length and either the string's
            entire data inline (for small strings) or an inlined prefix, an
            index of another buffer, and an offset pointing to a slice in that
            buffer (for non-small strings). Since it uses a variable number of
            data buffers, each Field with this type must have a corresponding
            entry in `variadicBufferCounts`.

            Table org.apache.arrow.flatbuf.Utf8View (//Schema.fbs) *)
        and Utf8View : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Utf8View.t Rt.wip
          end
        end

        (** Unicode with UTF-8 encoding

            Table org.apache.arrow.flatbuf.Utf8 (//Schema.fbs) *)
        and Utf8 : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Utf8.t Rt.wip
          end
        end

        (** A union is a complex type with children in Field By default ids in
            the type vector refer to the offsets in the children optionally
            typeIds provides an indirection between the child offset and the
            type id for each child `typeIds[offset]` is the id used in the type
            vector

            Table org.apache.arrow.flatbuf.Union (//Schema.fbs) *)
        and Union : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val mode : 'b Rt.buf -> ('b, t) Rt.fb -> UnionMode.t

          val type_ids :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.Int.Vector.t) Rt.fbopt

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Union.t Rt.wip
            val add_mode : UnionMode.t -> t -> t
            val add_type_ids : Rt.Int.Vector.t Rt.wip -> t -> t
          end
        end

        (** Timestamp is a 64-bit signed integer representing an elapsed time
            since a fixed epoch, stored in either of four units: seconds,
            milliseconds, microseconds or nanoseconds, and is optionally
            annotated with a timezone. Timestamp values do not include any leap
            seconds (in other words, all days are considered 86400 seconds
            long). Timestamps with a non-empty timezone
            ------------------------------------ If a Timestamp column has a
            non-empty timezone value, its epoch is 1970-01-01 00:00:00 (January
            1st 1970, midnight) in the *UTC* timezone (the Unix epoch),
            regardless of the Timestamp's own timezone. Therefore, timestamp
            values with a non-empty timezone correspond to physical points in
            time together with some additional information about how the data
            was obtained and/or how to display it (the timezone). For example,
            the timestamp value 0 with the timezone string "Europe/Paris"
            corresponds to "January 1st 1970, 00h00" in the UTC timezone, but
            the application may prefer to display it as "January 1st 1970,
            01h00" in the Europe/Paris timezone (which is the same physical
            point in time). One consequence is that timestamp values with a
            non-empty timezone can be compared and ordered directly, since they
            all share the same well-known point of reference (the Unix epoch).
            Timestamps with an unset / empty timezone
            ----------------------------------------- If a Timestamp column has
            no timezone value, its epoch is 1970-01-01 00:00:00 (January 1st
            1970, midnight) in an *unknown* timezone. Therefore, timestamp
            values without a timezone cannot be meaningfully interpreted as
            physical points in time, but only as calendar / clock indications
            ("wall clock time") in an unspecified timezone. For example, the
            timestamp value 0 with an empty timezone string corresponds to
            "January 1st 1970, 00h00" in an unknown timezone: there is not
            enough information to interpret it as a well-defined physical point
            in time. One consequence is that timestamp values without a timezone
            cannot be reliably compared or ordered, since they may have
            different points of reference. In particular, it is *not* possible
            to interpret an unset or empty timezone as the same as "UTC".
            Conversion between timezones ---------------------------- If a
            Timestamp column has a non-empty timezone, changing the timezone to
            a different non-empty value is a metadata-only operation: the
            timestamp values need not change as their point of reference remains
            the same (the Unix epoch). However, if a Timestamp column has no
            timezone value, changing it to a non-empty value requires to think
            about the desired semantics. One possibility is to assume that the
            original timestamp values are relative to the epoch of the timezone
            being set; timestamp values should then adjusted to the Unix epoch
            (for example, changing the timezone from empty to "Europe/Paris"
            would require converting the timestamp values from "Europe/Paris" to
            "UTC", which seems counter-intuitive but is nevertheless correct).
            Guidelines for encoding data from external libraries
            ---------------------------------------------------- Date & time
            libraries often have multiple different data types for temporal
            data. In order to ease interoperability between different
            implementations the Arrow project has some recommendations for
            encoding these types into a Timestamp column. An "instant"
            represents a physical point in time that has no relevant timezone
            (for example, astronomical data). To encode an instant, use a
            Timestamp with the timezone string set to "UTC", and make sure the
            Timestamp values are relative to the UTC epoch (January 1st 1970,
            midnight). A "zoned date-time" represents a physical point in time
            annotated with an informative timezone (for example, the timezone in
            which the data was recorded). To encode a zoned date-time, use a
            Timestamp with the timezone string set to the name of the timezone,
            and make sure the Timestamp values are relative to the UTC epoch
            (January 1st 1970, midnight). (There is some ambiguity between an
            instant and a zoned date-time with the UTC timezone. Both of these
            are stored the same in Arrow. Typically, this distinction does not
            matter. If it does, then an application should use custom metadata
            or an extension type to distinguish between the two cases.) An
            "offset date-time" represents a physical point in time combined with
            an explicit offset from UTC. To encode an offset date-time, use a
            Timestamp with the timezone string set to the numeric timezone
            offset string (e.g. "+03:00"), and make sure the Timestamp values
            are relative to the UTC epoch (January 1st 1970, midnight). A "naive
            date-time" (also called "local date-time" in some libraries)
            represents a wall clock time combined with a calendar date, but with
            no indication of how to map this information to a physical point in
            time. Naive date-times must be handled with care because of this
            missing information, and also because daylight saving time (DST) may
            make some values ambiguous or nonexistent. A naive date-time may be
            stored as a struct with Date and Time fields. However, it may also
            be encoded into a Timestamp column with an empty timezone. The
            timestamp values should be computed "as if" the timezone of the
            date-time values was UTC; for example, the naive date-time "January
            1st 1970, 00h00" would be encoded as timestamp value 0.

            Table org.apache.arrow.flatbuf.Timestamp (//Schema.fbs) *)
        and Timestamp : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> TimeUnit.t

          val timezone :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt
          (** The timezone is an optional string indicating the name of a
              timezone, one of: * As used in the Olson timezone database (the
              "tz database" or "tzdata"), such as "America/New_York". * An
              absolute timezone offset of the form "+XX:XX" or "-XX:XX", such as
              "+07:30". Whether a timezone string is present indicates different
              semantics about the data (see above). *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Timestamp.t Rt.wip
            val add_unit : TimeUnit.t -> t -> t
            val add_timezone : Rt.String.t Rt.wip -> t -> t
          end
        end

        (** Time is either a 32-bit or 64-bit signed integer type representing
            an elapsed time since midnight, stored in either of four units:
            seconds, milliseconds, microseconds or nanoseconds. The integer
            `bitWidth` depends on the `unit` and must be one of the following: *
            SECOND and MILLISECOND: 32 bits * MICROSECOND and NANOSECOND: 64
            bits The allowed values are between 0 (inclusive) and 86400
            (=24*60*60) seconds (exclusive), adjusted for the time unit (for
            example, up to 86400000 exclusive for the MILLISECOND unit). This
            definition doesn't allow for leap seconds. Time values from
            measurements with leap seconds will need to be corrected when
            ingesting into Arrow (for example by replacing the value 86400 with
            86399).

            Table org.apache.arrow.flatbuf.Time (//Schema.fbs) *)
        and Time : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> TimeUnit.t
          val bit_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Time.t Rt.wip
            val add_unit : TimeUnit.t -> t -> t
            val add_bit_width : Rt.Int.t -> t -> t
          end
        end

        (** A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
            (according to the physical memory layout). We used Struct_ here as
            Struct is a reserved word in Flatbuffers

            Table org.apache.arrow.flatbuf.Struct_ (//Schema.fbs) *)
        and Struct_ : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Struct_.t Rt.wip
          end
        end

        (** ----------------------------------------------------------------------
            A Schema describes the columns in a row batch

            Table org.apache.arrow.flatbuf.Schema (//Schema.fbs) *)
        and Schema : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val endianness : 'b Rt.buf -> ('b, t) Rt.fb -> Endianness.t
          (** endianness of the buffer it is Little Endian by default if
              endianness doesn't match the underlying system then the vectors
              need to be converted *)

          val fields :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Field.Vector.t) Rt.fbopt

          val custom_metadata :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, KeyValue.Vector.t) Rt.fbopt

          val features :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Feature.Vector.t) Rt.fbopt
          (** Features used in the stream/file. *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Schema.t Rt.wip
            val add_endianness : Endianness.t -> t -> t
            val add_fields : Field.Vector.t Rt.wip -> t -> t
            val add_custom_metadata : KeyValue.Vector.t Rt.wip -> t -> t
            val add_features : Feature.Vector.t Rt.wip -> t -> t
          end
        end

        (** Contains two child arrays, run_ends and values. The run_ends child
            array must be a 16/32/64-bit integer array which encodes the indices
            at which the run with the value in each corresponding index in the
            values child array ends. Like list/struct types, the value array can
            be of any type.

            Table org.apache.arrow.flatbuf.RunEndEncoded (//Schema.fbs) *)
        and RunEndEncoded : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> RunEndEncoded.t Rt.wip
          end
        end

        (** These are stored in the flatbuffer in the Type union below

            Table org.apache.arrow.flatbuf.Null (//Schema.fbs) *)
        and Null : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Null.t Rt.wip
          end
        end

        (** A Map is a logical nested type that is represented as List<entries:
            Struct<key: K, value: V>> In this layout, the keys and values are
            each respectively contiguous. We do not constrain the key and value
            types, so the application is responsible for ensuring that the keys
            are hashable and unique. Whether the keys are sorted may be set in
            the metadata for this field. In a field with Map type, the field has
            a child Struct field, which then has two children: key type and the
            second the value type. The names of the child fields may be
            respectively "entries", "key", and "value", but this is not
            enforced. Map ```text - child[0] entries: Struct - child[0] key: K -
            child[1] value: V ``` Neither the "entries" field nor the "key"
            field may be nullable. The metadata is structured so that Arrow
            systems without special handling for Map can make Map an alias for
            List. The "layout" attribute for the Map field must have the same
            contents as a List.

            Table org.apache.arrow.flatbuf.Map (//Schema.fbs) *)
        and Map : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val keys_sorted : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** Set to true if the keys within each value are sorted *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Map.t Rt.wip
            val add_keys_sorted : Rt.Bool.t -> t -> t
          end
        end

        (** Represents the same logical types that List can, but contains
            offsets and sizes allowing for writes in any order and sharing of
            child values among list values.

            Table org.apache.arrow.flatbuf.ListView (//Schema.fbs) *)
        and ListView : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> ListView.t Rt.wip
          end
        end

        (* Table org.apache.arrow.flatbuf.List (//Schema.fbs) *)
        and List : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> List.t Rt.wip
          end
        end

        (** Same as Utf8, but with 64-bit offsets, allowing to represent
            extremely large data values.

            Table org.apache.arrow.flatbuf.LargeUtf8 (//Schema.fbs) *)
        and LargeUtf8 : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeUtf8.t Rt.wip
          end
        end

        (** Same as ListView, but with 64-bit offsets and sizes, allowing to
            represent extremely large data values.

            Table org.apache.arrow.flatbuf.LargeListView (//Schema.fbs) *)
        and LargeListView : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeListView.t Rt.wip
          end
        end

        (** Same as List, but with 64-bit offsets, allowing to represent
            extremely large data values.

            Table org.apache.arrow.flatbuf.LargeList (//Schema.fbs) *)
        and LargeList : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeList.t Rt.wip
          end
        end

        (** Same as Binary, but with 64-bit offsets, allowing to represent
            extremely large data values.

            Table org.apache.arrow.flatbuf.LargeBinary (//Schema.fbs) *)
        and LargeBinary : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeBinary.t Rt.wip
          end
        end

        (** ----------------------------------------------------------------------
            user defined key value pairs to add custom metadata to arrow key
            namespacing is the responsibility of the user

            Table org.apache.arrow.flatbuf.KeyValue (//Schema.fbs) *)
        and KeyValue : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val key : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt
          val value : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> KeyValue.t Rt.wip
            val add_key : Rt.String.t Rt.wip -> t -> t
            val add_value : Rt.String.t Rt.wip -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.Interval (//Schema.fbs) *)
        and Interval : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> IntervalUnit.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Interval.t Rt.wip
            val add_unit : IntervalUnit.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.Int (//Schema.fbs) *)
        and Int : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val bit_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          val is_signed : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Int.t Rt.wip
            val add_bit_width : Rt.Int.t -> t -> t
            val add_is_signed : Rt.Bool.t -> t -> t
          end
        end

        (** ----------------------------------------------------------------------
            Arrow File metadata

            Table org.apache.arrow.flatbuf.Footer (//File.fbs) *)
        and Footer : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val extension : string option
          val identifier : string option

          val root :
            ?size_prefixed:bool ->
            ?off:int ->
            'b Flatbuffers.Primitives.t ->
            'b ->
            t Rt.root

          val finish_buf :
            ?size_prefixed:bool ->
            'a Flatbuffers.Primitives.t ->
            Rt.Builder.t ->
            t Rt.wip ->
            'a

          val version : 'b Rt.buf -> ('b, t) Rt.fb -> MetadataVersion.t
          val schema : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Schema.t) Rt.fbopt

          val dictionaries :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Block.Vector.t) Rt.fbopt

          val record_batches :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Block.Vector.t) Rt.fbopt

          val custom_metadata :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, KeyValue.Vector.t) Rt.fbopt
          (** User-defined metadata *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Footer.t Rt.wip
            val add_version : MetadataVersion.t -> t -> t
            val add_schema : Schema.t Rt.wip -> t -> t
            val add_dictionaries : Block.Vector.t Rt.wip -> t -> t
            val add_record_batches : Block.Vector.t Rt.wip -> t -> t
            val add_custom_metadata : KeyValue.Vector.t Rt.wip -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.FloatingPoint (//Schema.fbs) *)
        and FloatingPoint : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val precision : 'b Rt.buf -> ('b, t) Rt.fb -> Precision.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> FloatingPoint.t Rt.wip
            val add_precision : Precision.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.FixedSizeList (//Schema.fbs) *)
        and FixedSizeList : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val list_size : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of list items per value *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> FixedSizeList.t Rt.wip
            val add_list_size : Rt.Int.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.FixedSizeBinary (//Schema.fbs) *)
        and FixedSizeBinary : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val byte_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of bytes per value *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> FixedSizeBinary.t Rt.wip
            val add_byte_width : Rt.Int.t -> t -> t
          end
        end

        (** ----------------------------------------------------------------------
            A field represents a named column in a record / row batch or child
            of a nested type.

            Table org.apache.arrow.flatbuf.Field (//Schema.fbs) *)
        and Field : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val name : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt
          (** Name is not required (e.g., in a List) *)

          val nullable : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** Whether or not this field can contain nulls. Should be true in
              general. *)

          val type_type : 'b Rt.buf -> ('b, t) Rt.fb -> Type.t

          val type_ :
            ?none:'a ->
            ?null:(('b, Null.t) Rt.fb -> 'a) ->
            ?int:(('b, Int.t) Rt.fb -> 'a) ->
            ?floating_point:(('b, FloatingPoint.t) Rt.fb -> 'a) ->
            ?binary:(('b, Binary.t) Rt.fb -> 'a) ->
            ?utf8:(('b, Utf8.t) Rt.fb -> 'a) ->
            ?bool:(('b, Bool.t) Rt.fb -> 'a) ->
            ?decimal:(('b, Decimal.t) Rt.fb -> 'a) ->
            ?date:(('b, Date.t) Rt.fb -> 'a) ->
            ?time:(('b, Time.t) Rt.fb -> 'a) ->
            ?timestamp:(('b, Timestamp.t) Rt.fb -> 'a) ->
            ?interval:(('b, Interval.t) Rt.fb -> 'a) ->
            ?list:(('b, List.t) Rt.fb -> 'a) ->
            ?struct_:(('b, Struct_.t) Rt.fb -> 'a) ->
            ?union:(('b, Union.t) Rt.fb -> 'a) ->
            ?fixed_size_binary:(('b, FixedSizeBinary.t) Rt.fb -> 'a) ->
            ?fixed_size_list:(('b, FixedSizeList.t) Rt.fb -> 'a) ->
            ?map:(('b, Map.t) Rt.fb -> 'a) ->
            ?duration:(('b, Duration.t) Rt.fb -> 'a) ->
            ?large_binary:(('b, LargeBinary.t) Rt.fb -> 'a) ->
            ?large_utf8:(('b, LargeUtf8.t) Rt.fb -> 'a) ->
            ?large_list:(('b, LargeList.t) Rt.fb -> 'a) ->
            ?run_end_encoded:(('b, RunEndEncoded.t) Rt.fb -> 'a) ->
            ?binary_view:(('b, BinaryView.t) Rt.fb -> 'a) ->
            ?utf8_view:(('b, Utf8View.t) Rt.fb -> 'a) ->
            ?list_view:(('b, ListView.t) Rt.fb -> 'a) ->
            ?large_list_view:(('b, LargeListView.t) Rt.fb -> 'a) ->
            default:(Type.t -> 'a) ->
            'b Rt.buf ->
            ('b, t) Rt.fb ->
            'a
          (** This is the type of the decoded value if the field is dictionary
              encoded. *)

          val dictionary :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, DictionaryEncoding.t) Rt.fbopt
          (** Present only if the field is dictionary encoded. *)

          val children : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Vector.t) Rt.fbopt
          (** children apply only to nested data types like Struct, List and
              Union. For primitive types children will have length 0. *)

          val custom_metadata :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, KeyValue.Vector.t) Rt.fbopt
          (** User-defined metadata *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Field.t Rt.wip
            val add_name : Rt.String.t Rt.wip -> t -> t
            val add_nullable : Rt.Bool.t -> t -> t
            val add_type__null : Null.t Rt.wip -> t -> t
            val add_type__int : Int.t Rt.wip -> t -> t
            val add_type__floating_point : FloatingPoint.t Rt.wip -> t -> t
            val add_type__binary : Binary.t Rt.wip -> t -> t
            val add_type__utf8 : Utf8.t Rt.wip -> t -> t
            val add_type__bool : Bool.t Rt.wip -> t -> t
            val add_type__decimal : Decimal.t Rt.wip -> t -> t
            val add_type__date : Date.t Rt.wip -> t -> t
            val add_type__time : Time.t Rt.wip -> t -> t
            val add_type__timestamp : Timestamp.t Rt.wip -> t -> t
            val add_type__interval : Interval.t Rt.wip -> t -> t
            val add_type__list : List.t Rt.wip -> t -> t
            val add_type__struct_ : Struct_.t Rt.wip -> t -> t
            val add_type__union : Union.t Rt.wip -> t -> t
            val add_type__fixed_size_binary : FixedSizeBinary.t Rt.wip -> t -> t
            val add_type__fixed_size_list : FixedSizeList.t Rt.wip -> t -> t
            val add_type__map : Map.t Rt.wip -> t -> t
            val add_type__duration : Duration.t Rt.wip -> t -> t
            val add_type__large_binary : LargeBinary.t Rt.wip -> t -> t
            val add_type__large_utf8 : LargeUtf8.t Rt.wip -> t -> t
            val add_type__large_list : LargeList.t Rt.wip -> t -> t
            val add_type__run_end_encoded : RunEndEncoded.t Rt.wip -> t -> t
            val add_type__binary_view : BinaryView.t Rt.wip -> t -> t
            val add_type__utf8_view : Utf8View.t Rt.wip -> t -> t
            val add_type__list_view : ListView.t Rt.wip -> t -> t
            val add_type__large_list_view : LargeListView.t Rt.wip -> t -> t
            val add_dictionary : DictionaryEncoding.t Rt.wip -> t -> t
            val add_children : Field.Vector.t Rt.wip -> t -> t
            val add_custom_metadata : KeyValue.Vector.t Rt.wip -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.Duration (//Schema.fbs) *)
        and Duration : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> TimeUnit.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Duration.t Rt.wip
            val add_unit : TimeUnit.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.DictionaryEncoding (//Schema.fbs) *)
        and DictionaryEncoding : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val id : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The known dictionary id in the application where this data is
              used. In the file or streaming formats, the dictionary ids are
              found in the DictionaryBatch messages *)

          val index_type : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Int.t) Rt.fbopt
          (** The dictionary indices are constrained to be non-negative
              integers. If this field is null, the indices must be signed int32.
              To maximize cross-language compatibility and performance,
              implementations are recommended to prefer signed integer types
              over unsigned integer types and to avoid uint64 indices unless
              they are required by an application. *)

          val is_ordered : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** By default, dictionaries are not ordered, or the order does not
              have semantic meaning. In some statistical, applications,
              dictionary-encoding is used to represent ordered categorical data,
              and we provide a way to preserve that metadata here *)

          val dictionary_kind : 'b Rt.buf -> ('b, t) Rt.fb -> DictionaryKind.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> DictionaryEncoding.t Rt.wip
            val add_id : Rt.Long.t -> t -> t
            val add_index_type : Int.t Rt.wip -> t -> t
            val add_is_ordered : Rt.Bool.t -> t -> t
            val add_dictionary_kind : DictionaryKind.t -> t -> t
          end
        end

        (** Exact decimal value represented as an integer value in two's
            complement. Currently 32-bit (4-byte), 64-bit (8-byte), 128-bit
            (16-byte) and 256-bit (32-byte) integers are used. The
            representation uses the endianness indicated in the Schema.

            Table org.apache.arrow.flatbuf.Decimal (//Schema.fbs) *)
        and Decimal : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val precision : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Total number of decimal digits *)

          val scale : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of digits after the decimal point "." *)

          val bit_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of bits per value. The accepted widths are 32, 64, 128 and
              256. We use bitWidth for consistency with Int::bitWidth. *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Decimal.t Rt.wip
            val add_precision : Rt.Int.t -> t -> t
            val add_scale : Rt.Int.t -> t -> t
            val add_bit_width : Rt.Int.t -> t -> t
          end
        end

        (** Date is either a 32-bit or 64-bit signed integer type representing
            an elapsed time since UNIX epoch (1970-01-01), stored in either of
            two units: * Milliseconds (64 bits) indicating UNIX time elapsed
            since the epoch (no leap seconds), where the values are evenly
            divisible by 86400000 * Days (32 bits) since the UNIX epoch

            Table org.apache.arrow.flatbuf.Date (//Schema.fbs) *)
        and Date : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> DateUnit.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Date.t Rt.wip
            val add_unit : DateUnit.t -> t -> t
          end
        end

        (** ----------------------------------------------------------------------
            A Buffer represents a single contiguous memory segment

            Struct org.apache.arrow.flatbuf.Buffer (//Schema.fbs) *)
        and Buffer : sig
          type t = Rt.Long.t * Rt.Long.t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t

          val offset : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The relative offset into the shared memory page where the bytes
              for this buffer starts *)

          val length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The absolute length (in bytes) of the memory buffer. The memory is
              found from offset (inclusive) to offset + length (non-inclusive).
              When building messages using the encapsulated IPC message, padding
              bytes may be written after a buffer, but such padding bytes do not
              need to be accounted for in the size here. *)
        end

        (* Table org.apache.arrow.flatbuf.Bool (//Schema.fbs) *)
        and Bool : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Bool.t Rt.wip
          end
        end

        (* Struct org.apache.arrow.flatbuf.Block (//File.fbs) *)
        and Block : sig
          type t = Rt.Long.t * Rt.Int.t * Rt.Long.t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t

          val offset : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** Index to the start of the RecordBlock (note this is past the
              Message header) *)

          val meta_data_length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Length of the metadata *)

          val body_length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** Length of the data (this is aligned so there can be a gap between
              this and the metadata). *)
        end

        (** Logically the same as Binary, but the internal representation uses a
            view struct that contains the string length and either the string's
            entire data inline (for small strings) or an inlined prefix, an
            index of another buffer, and an offset pointing to a slice in that
            buffer (for non-small strings). Since it uses a variable number of
            data buffers, each Field with this type must have a corresponding
            entry in `variadicBufferCounts`.

            Table org.apache.arrow.flatbuf.BinaryView (//Schema.fbs) *)
        and BinaryView : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> BinaryView.t Rt.wip
          end
        end

        (** Opaque binary data

            Table org.apache.arrow.flatbuf.Binary (//Schema.fbs) *)
        and Binary : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Binary.t Rt.wip
          end
        end
      end
      (* Flatbuf *)
    end
    (* Arrow *)
  end
  (* Apache *)
end
(* Org *)
