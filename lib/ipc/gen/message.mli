(** Automatically generated by the FlatBuffers compiler

    root type: org.apache.arrow.flatbuf.Message (//Message.fbs) flatc version:
    23.3.3 *)

module Rt : Flatbuffers.Runtime.Intf

module rec Org : sig
  module rec Apache : sig
    module rec Arrow : sig
      module rec Flatbuf : sig
        (* Enum org.apache.arrow.flatbuf.UnionMode (//Schema.fbs) *)
        module rec UnionMode : sig
          type t = private Rt.Short.t

          val sparse : t
          val dense : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** ----------------------------------------------------------------------
            Top-level Type value, enabling extensible type-specific metadata. We
            can add new logical types to Type without breaking backwards
            compatibility

            Union org.apache.arrow.flatbuf.Type (//Schema.fbs) *)
        and Type : sig
          type t = private Rt.UType.t

          val none : t
          val null : t
          val int : t
          val floating_point : t
          val binary : t
          val utf8 : t
          val bool : t
          val decimal : t
          val date : t
          val time : t
          val timestamp : t
          val interval : t
          val list : t
          val struct_ : t
          val union : t
          val fixed_size_binary : t
          val fixed_size_list : t
          val map : t
          val duration : t
          val large_binary : t
          val large_utf8 : t
          val large_list : t
          val run_end_encoded : t
          val binary_view : t
          val utf8_view : t
          val list_view : t
          val large_list_view : t
          val to_string : t -> string
        end

        (* Enum org.apache.arrow.flatbuf.TimeUnit (//Schema.fbs) *)
        and TimeUnit : sig
          type t = private Rt.Short.t

          val second : t
          val millisecond : t
          val microsecond : t
          val nanosecond : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Union org.apache.arrow.flatbuf.SparseTensorIndex (//SparseTensor.fbs) *)
        and SparseTensorIndex : sig
          type t = private Rt.UType.t

          val none : t
          val sparse_tensor_index_coo : t
          val sparse_matrix_index_csx : t
          val sparse_tensor_index_csf : t
          val to_string : t -> string
        end

        (* Enum org.apache.arrow.flatbuf.SparseMatrixCompressedAxis (//SparseTensor.fbs) *)
        and SparseMatrixCompressedAxis : sig
          type t = private Rt.Short.t

          val row : t
          val column : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.Precision (//Schema.fbs) *)
        and Precision : sig
          type t = private Rt.Short.t

          val half : t
          val single : t
          val double : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.MetadataVersion (//Schema.fbs) *)
        and MetadataVersion : sig
          type t = private Rt.Short.t

          val v1 : t
          (** 0.1.0 (October 2016). *)

          val v2 : t
          (** 0.2.0 (February 2017). Non-backwards compatible with V1. *)

          val v3 : t
          (** 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible
              with V2. *)

          val v4 : t
          (** >= 0.8.0 (December 2017). Non-backwards compatible with V3. *)

          val v5 : t
          (** >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can
              read V4 metadata and IPC messages). Implementations are
              recommended to provide a V4 compatibility mode with V5 format
              changes disabled. Incompatible changes between V4 and V5: - Union
              buffer layout has changed. In V5, Unions don't have a validity
              bitmap buffer. *)

          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** ----------------------------------------------------------------------
            The root Message type This union enables us to easily send different
            message types without redundant storage, and in the future we can
            easily add new message types. Arrow implementations do not need to
            implement all of the message types, which may include experimental
            metadata types. For maximum compatibility, it is best to send data
            using RecordBatch

            Union org.apache.arrow.flatbuf.MessageHeader (//Message.fbs) *)
        and MessageHeader : sig
          type t = private Rt.UType.t

          val none : t
          val schema : t
          val dictionary_batch : t
          val record_batch : t
          val tensor : t
          val sparse_tensor : t
          val to_string : t -> string
        end

        (* Enum org.apache.arrow.flatbuf.IntervalUnit (//Schema.fbs) *)
        and IntervalUnit : sig
          type t = private Rt.Short.t

          val year_month : t
          val day_time : t
          val month_day_nano : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** Represents Arrow Features that might not have full support within
            implementations. This is intended to be used in two scenarios: 1. A
            mechanism for readers of Arrow Streams and files to understand that
            the stream or file makes use of a feature that isn't supported or
            unknown to the implementation (and therefore can meet the Arrow
            forward compatibility guarantees). 2. A means of negotiating between
            a client and server what features a stream is allowed to use. The
            enums values here are intended to represent higher level features,
            additional details may be negotiated with key-value pairs specific
            to the protocol. Enums added to this list should be assigned
            power-of-two values to facilitate exchanging and comparing bitmaps
            for supported features.

            Enum org.apache.arrow.flatbuf.Feature (//Schema.fbs) *)
        and Feature : sig
          type t = private Rt.Long.t

          val unused : t
          (** Needed to make flatbuffers happy. *)

          val dictionary_replacement : t
          (** The stream makes use of multiple full dictionaries with the same
              ID and assumes clients implement dictionary replacement correctly.
          *)

          val compressed_body : t
          (** The stream makes use of compressed bodies as described in
              Message.fbs. *)

          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** ----------------------------------------------------------------------
            Endianness of the platform producing the data

            Enum org.apache.arrow.flatbuf.Endianness (//Schema.fbs) *)
        and Endianness : sig
          type t = private Rt.Short.t

          val little : t
          val big : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** ----------------------------------------------------------------------
            Dictionary encoding metadata Maintained for forwards compatibility,
            in the future Dictionaries might be explicit maps between integers
            and values allowing for non-contiguous index values

            Enum org.apache.arrow.flatbuf.DictionaryKind (//Schema.fbs) *)
        and DictionaryKind : sig
          type t = private Rt.Short.t

          val dense_array : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.DateUnit (//Schema.fbs) *)
        and DateUnit : sig
          type t = private Rt.Short.t

          val day : t
          val millisecond : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (* Enum org.apache.arrow.flatbuf.CompressionType (//Message.fbs) *)
        and CompressionType : sig
          type t = private Rt.Byte.t

          val lz4_frame : t
          val zstd : t
          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** Provided for forward compatibility in case we need to support
            different strategies for compressing the IPC message body (like
            whole-body compression rather than buffer-level) in the future

            Enum org.apache.arrow.flatbuf.BodyCompressionMethod (//Message.fbs)
        *)
        and BodyCompressionMethod : sig
          type t = private Rt.Byte.t

          val buffer : t
          (** Each constituent buffer is first compressed with the indicated
              compressor, and then written with the uncompressed length in the
              first 8 bytes as a 64-bit little-endian signed integer followed by
              the compressed buffer bytes (and then padding as required by the
              protocol). The uncompressed length may be set to -1 to indicate
              that the data that follows is not compressed, which can be useful
              for cases where compression does not yield appreciable savings. *)

          val to_string : t -> string

          module Vector :
            Rt.VectorS with type 'b elt := t and type builder_elt := t
        end

        (** Logically the same as Utf8, but the internal representation uses a
            view struct that contains the string length and either the string's
            entire data inline (for small strings) or an inlined prefix, an
            index of another buffer, and an offset pointing to a slice in that
            buffer (for non-small strings). Since it uses a variable number of
            data buffers, each Field with this type must have a corresponding
            entry in `variadicBufferCounts`.

            Table org.apache.arrow.flatbuf.Utf8View (//Schema.fbs) *)
        and Utf8View : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Utf8View.t Rt.wip
          end
        end

        (** Unicode with UTF-8 encoding

            Table org.apache.arrow.flatbuf.Utf8 (//Schema.fbs) *)
        and Utf8 : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Utf8.t Rt.wip
          end
        end

        (** A union is a complex type with children in Field By default ids in
            the type vector refer to the offsets in the children optionally
            typeIds provides an indirection between the child offset and the
            type id for each child `typeIds[offset]` is the id used in the type
            vector

            Table org.apache.arrow.flatbuf.Union (//Schema.fbs) *)
        and Union : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val mode : 'b Rt.buf -> ('b, t) Rt.fb -> UnionMode.t

          val type_ids :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.Int.Vector.t) Rt.fbopt

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Union.t Rt.wip
            val add_mode : UnionMode.t -> t -> t
            val add_type_ids : Rt.Int.Vector.t Rt.wip -> t -> t
          end
        end

        (** Timestamp is a 64-bit signed integer representing an elapsed time
            since a fixed epoch, stored in either of four units: seconds,
            milliseconds, microseconds or nanoseconds, and is optionally
            annotated with a timezone. Timestamp values do not include any leap
            seconds (in other words, all days are considered 86400 seconds
            long). Timestamps with a non-empty timezone
            ------------------------------------ If a Timestamp column has a
            non-empty timezone value, its epoch is 1970-01-01 00:00:00 (January
            1st 1970, midnight) in the *UTC* timezone (the Unix epoch),
            regardless of the Timestamp's own timezone. Therefore, timestamp
            values with a non-empty timezone correspond to physical points in
            time together with some additional information about how the data
            was obtained and/or how to display it (the timezone). For example,
            the timestamp value 0 with the timezone string "Europe/Paris"
            corresponds to "January 1st 1970, 00h00" in the UTC timezone, but
            the application may prefer to display it as "January 1st 1970,
            01h00" in the Europe/Paris timezone (which is the same physical
            point in time). One consequence is that timestamp values with a
            non-empty timezone can be compared and ordered directly, since they
            all share the same well-known point of reference (the Unix epoch).
            Timestamps with an unset / empty timezone
            ----------------------------------------- If a Timestamp column has
            no timezone value, its epoch is 1970-01-01 00:00:00 (January 1st
            1970, midnight) in an *unknown* timezone. Therefore, timestamp
            values without a timezone cannot be meaningfully interpreted as
            physical points in time, but only as calendar / clock indications
            ("wall clock time") in an unspecified timezone. For example, the
            timestamp value 0 with an empty timezone string corresponds to
            "January 1st 1970, 00h00" in an unknown timezone: there is not
            enough information to interpret it as a well-defined physical point
            in time. One consequence is that timestamp values without a timezone
            cannot be reliably compared or ordered, since they may have
            different points of reference. In particular, it is *not* possible
            to interpret an unset or empty timezone as the same as "UTC".
            Conversion between timezones ---------------------------- If a
            Timestamp column has a non-empty timezone, changing the timezone to
            a different non-empty value is a metadata-only operation: the
            timestamp values need not change as their point of reference remains
            the same (the Unix epoch). However, if a Timestamp column has no
            timezone value, changing it to a non-empty value requires to think
            about the desired semantics. One possibility is to assume that the
            original timestamp values are relative to the epoch of the timezone
            being set; timestamp values should then adjusted to the Unix epoch
            (for example, changing the timezone from empty to "Europe/Paris"
            would require converting the timestamp values from "Europe/Paris" to
            "UTC", which seems counter-intuitive but is nevertheless correct).
            Guidelines for encoding data from external libraries
            ---------------------------------------------------- Date & time
            libraries often have multiple different data types for temporal
            data. In order to ease interoperability between different
            implementations the Arrow project has some recommendations for
            encoding these types into a Timestamp column. An "instant"
            represents a physical point in time that has no relevant timezone
            (for example, astronomical data). To encode an instant, use a
            Timestamp with the timezone string set to "UTC", and make sure the
            Timestamp values are relative to the UTC epoch (January 1st 1970,
            midnight). A "zoned date-time" represents a physical point in time
            annotated with an informative timezone (for example, the timezone in
            which the data was recorded). To encode a zoned date-time, use a
            Timestamp with the timezone string set to the name of the timezone,
            and make sure the Timestamp values are relative to the UTC epoch
            (January 1st 1970, midnight). (There is some ambiguity between an
            instant and a zoned date-time with the UTC timezone. Both of these
            are stored the same in Arrow. Typically, this distinction does not
            matter. If it does, then an application should use custom metadata
            or an extension type to distinguish between the two cases.) An
            "offset date-time" represents a physical point in time combined with
            an explicit offset from UTC. To encode an offset date-time, use a
            Timestamp with the timezone string set to the numeric timezone
            offset string (e.g. "+03:00"), and make sure the Timestamp values
            are relative to the UTC epoch (January 1st 1970, midnight). A "naive
            date-time" (also called "local date-time" in some libraries)
            represents a wall clock time combined with a calendar date, but with
            no indication of how to map this information to a physical point in
            time. Naive date-times must be handled with care because of this
            missing information, and also because daylight saving time (DST) may
            make some values ambiguous or nonexistent. A naive date-time may be
            stored as a struct with Date and Time fields. However, it may also
            be encoded into a Timestamp column with an empty timezone. The
            timestamp values should be computed "as if" the timezone of the
            date-time values was UTC; for example, the naive date-time "January
            1st 1970, 00h00" would be encoded as timestamp value 0.

            Table org.apache.arrow.flatbuf.Timestamp (//Schema.fbs) *)
        and Timestamp : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> TimeUnit.t

          val timezone :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt
          (** The timezone is an optional string indicating the name of a
              timezone, one of: * As used in the Olson timezone database (the
              "tz database" or "tzdata"), such as "America/New_York". * An
              absolute timezone offset of the form "+XX:XX" or "-XX:XX", such as
              "+07:30". Whether a timezone string is present indicates different
              semantics about the data (see above). *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Timestamp.t Rt.wip
            val add_unit : TimeUnit.t -> t -> t
            val add_timezone : Rt.String.t Rt.wip -> t -> t
          end
        end

        (** Time is either a 32-bit or 64-bit signed integer type representing
            an elapsed time since midnight, stored in either of four units:
            seconds, milliseconds, microseconds or nanoseconds. The integer
            `bitWidth` depends on the `unit` and must be one of the following: *
            SECOND and MILLISECOND: 32 bits * MICROSECOND and NANOSECOND: 64
            bits The allowed values are between 0 (inclusive) and 86400
            (=24*60*60) seconds (exclusive), adjusted for the time unit (for
            example, up to 86400000 exclusive for the MILLISECOND unit). This
            definition doesn't allow for leap seconds. Time values from
            measurements with leap seconds will need to be corrected when
            ingesting into Arrow (for example by replacing the value 86400 with
            86399).

            Table org.apache.arrow.flatbuf.Time (//Schema.fbs) *)
        and Time : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> TimeUnit.t
          val bit_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Time.t Rt.wip
            val add_unit : TimeUnit.t -> t -> t
            val add_bit_width : Rt.Int.t -> t -> t
          end
        end

        (** ----------------------------------------------------------------------
            Data structures for dense tensors Shape data for a single axis in a
            tensor

            Table org.apache.arrow.flatbuf.TensorDim (//Tensor.fbs) *)
        and TensorDim : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val size : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** Length of dimension *)

          val name : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt
          (** Name of the dimension, optional *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> TensorDim.t Rt.wip
            val add_size : Rt.Long.t -> t -> t
            val add_name : Rt.String.t Rt.wip -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.Tensor (//Tensor.fbs) *)
        and Tensor : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val type_type : 'b Rt.buf -> ('b, t) Rt.fb -> Type.t

          val type_ :
            ?none:'a ->
            ?null:(('b, Null.t) Rt.fb -> 'a) ->
            ?int:(('b, Int.t) Rt.fb -> 'a) ->
            ?floating_point:(('b, FloatingPoint.t) Rt.fb -> 'a) ->
            ?binary:(('b, Binary.t) Rt.fb -> 'a) ->
            ?utf8:(('b, Utf8.t) Rt.fb -> 'a) ->
            ?bool:(('b, Bool.t) Rt.fb -> 'a) ->
            ?decimal:(('b, Decimal.t) Rt.fb -> 'a) ->
            ?date:(('b, Date.t) Rt.fb -> 'a) ->
            ?time:(('b, Time.t) Rt.fb -> 'a) ->
            ?timestamp:(('b, Timestamp.t) Rt.fb -> 'a) ->
            ?interval:(('b, Interval.t) Rt.fb -> 'a) ->
            ?list:(('b, List.t) Rt.fb -> 'a) ->
            ?struct_:(('b, Struct_.t) Rt.fb -> 'a) ->
            ?union:(('b, Union.t) Rt.fb -> 'a) ->
            ?fixed_size_binary:(('b, FixedSizeBinary.t) Rt.fb -> 'a) ->
            ?fixed_size_list:(('b, FixedSizeList.t) Rt.fb -> 'a) ->
            ?map:(('b, Map.t) Rt.fb -> 'a) ->
            ?duration:(('b, Duration.t) Rt.fb -> 'a) ->
            ?large_binary:(('b, LargeBinary.t) Rt.fb -> 'a) ->
            ?large_utf8:(('b, LargeUtf8.t) Rt.fb -> 'a) ->
            ?large_list:(('b, LargeList.t) Rt.fb -> 'a) ->
            ?run_end_encoded:(('b, RunEndEncoded.t) Rt.fb -> 'a) ->
            ?binary_view:(('b, BinaryView.t) Rt.fb -> 'a) ->
            ?utf8_view:(('b, Utf8View.t) Rt.fb -> 'a) ->
            ?list_view:(('b, ListView.t) Rt.fb -> 'a) ->
            ?large_list_view:(('b, LargeListView.t) Rt.fb -> 'a) ->
            default:(Type.t -> 'a) ->
            'b Rt.buf ->
            ('b, t) Rt.fb ->
            'a
          (** The type of data contained in a value cell. Currently only
              fixed-width value types are supported, no strings or nested types
          *)

          val shape :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, TensorDim.Vector.t) Rt.fb
          (** The dimensions of the tensor, optionally named *)

          val strides :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.Long.Vector.t) Rt.fbopt
          (** Non-negative byte offsets to advance one value cell along each
              dimension If omitted, default to row-major order (C-like). *)

          val data : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.t) Rt.fb
          (** The location and size of the tensor's data *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Tensor.t Rt.wip
            val add_type__null : Null.t Rt.wip -> t -> t
            val add_type__int : Int.t Rt.wip -> t -> t
            val add_type__floating_point : FloatingPoint.t Rt.wip -> t -> t
            val add_type__binary : Binary.t Rt.wip -> t -> t
            val add_type__utf8 : Utf8.t Rt.wip -> t -> t
            val add_type__bool : Bool.t Rt.wip -> t -> t
            val add_type__decimal : Decimal.t Rt.wip -> t -> t
            val add_type__date : Date.t Rt.wip -> t -> t
            val add_type__time : Time.t Rt.wip -> t -> t
            val add_type__timestamp : Timestamp.t Rt.wip -> t -> t
            val add_type__interval : Interval.t Rt.wip -> t -> t
            val add_type__list : List.t Rt.wip -> t -> t
            val add_type__struct_ : Struct_.t Rt.wip -> t -> t
            val add_type__union : Union.t Rt.wip -> t -> t
            val add_type__fixed_size_binary : FixedSizeBinary.t Rt.wip -> t -> t
            val add_type__fixed_size_list : FixedSizeList.t Rt.wip -> t -> t
            val add_type__map : Map.t Rt.wip -> t -> t
            val add_type__duration : Duration.t Rt.wip -> t -> t
            val add_type__large_binary : LargeBinary.t Rt.wip -> t -> t
            val add_type__large_utf8 : LargeUtf8.t Rt.wip -> t -> t
            val add_type__large_list : LargeList.t Rt.wip -> t -> t
            val add_type__run_end_encoded : RunEndEncoded.t Rt.wip -> t -> t
            val add_type__binary_view : BinaryView.t Rt.wip -> t -> t
            val add_type__utf8_view : Utf8View.t Rt.wip -> t -> t
            val add_type__list_view : ListView.t Rt.wip -> t -> t
            val add_type__large_list_view : LargeListView.t Rt.wip -> t -> t
            val add_shape : TensorDim.Vector.t Rt.wip -> t -> t
            val add_strides : Rt.Long.Vector.t Rt.wip -> t -> t
            val add_data : Buffer.t -> t -> t
          end
        end

        (** A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
            (according to the physical memory layout). We used Struct_ here as
            Struct is a reserved word in Flatbuffers

            Table org.apache.arrow.flatbuf.Struct_ (//Schema.fbs) *)
        and Struct_ : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Struct_.t Rt.wip
          end
        end

        (** Compressed Sparse Fiber (CSF) sparse tensor index.

            Table org.apache.arrow.flatbuf.SparseTensorIndexCSF
            (//SparseTensor.fbs) *)
        and SparseTensorIndexCsf : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val indptr_type : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Int.t) Rt.fb
          (** CSF is a generalization of compressed sparse row (CSR) index. See
              [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf) CSF
              index recursively compresses each dimension of a tensor into a set
              of prefix trees. Each path from a root to leaf forms one tensor
              non-zero index. CSF is implemented with two arrays of buffers and
              one arrays of integers. For example, let X be a 2x3x4x5 tensor and
              let it have the following 8 non-zero values: ```text X[0, 0, 0, 1]
              := 1 X[0, 0, 0, 2] := 2 X[0, 1, 0, 0] := 3 X[0, 1, 0, 2] := 4
              X[0, 1, 1, 0] := 5 X[1, 1, 1, 0] := 6 X[1, 1, 1, 1] := 7
              X[1, 1, 1, 2] := 8 ``` As a prefix tree this would be represented
              as: ```text 0 1 / \ | 0 1 1 / / \ | 0 0 1 1 /| /| | /| | 1 2 0 2 0
              0 1 2 ``` The type of values in indptrBuffers *)

          val indptr_buffers :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.Vector.t) Rt.fb
          (** indptrBuffers stores the sparsity structure. Each two consecutive
              dimensions in a tensor correspond to a buffer in indptrBuffers. A
              pair of consecutive values at `indptrBuffers[dim][i]` and
              `indptrBuffers[dim][i + 1]` signify a range of nodes in
              `indicesBuffers[dim + 1]` who are children of
              `indicesBuffers[dim][i]` node. For example, the indptrBuffers for
              the above X is: ```text indptrBuffer(X) =
              [                       [0, 2, 3],                       [0, 1, 3,
               4],                       [0, 2, 4, 5, 8]                     ].
              ``` *)

          val indices_type : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Int.t) Rt.fb
          (** The type of values in indicesBuffers *)

          val indices_buffers :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.Vector.t) Rt.fb
          (** indicesBuffers stores values of nodes. Each tensor dimension
              corresponds to a buffer in indicesBuffers. For example, the
              indicesBuffers for the above X is: ```text indicesBuffer(X) =
              [                        [0, 1],                        [0, 1, 1],
               [0, 0, 1, 1],                        [1, 2, 0, 2, 0, 0, 1, 2]    
               ]. ``` *)

          val axis_order :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.Int.Vector.t) Rt.fb
          (** axisOrder stores the sequence in which dimensions were traversed
              to produce the prefix tree. For example, the axisOrder for the
              above X is: ```text axisOrder(X) = [0, 1, 2, 3]. ``` *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> SparseTensorIndexCsf.t Rt.wip
            val add_indptr_type : Int.t Rt.wip -> t -> t
            val add_indptr_buffers : Buffer.Vector.t Rt.wip -> t -> t
            val add_indices_type : Int.t Rt.wip -> t -> t
            val add_indices_buffers : Buffer.Vector.t Rt.wip -> t -> t
            val add_axis_order : Rt.Int.Vector.t Rt.wip -> t -> t
          end
        end

        (** ----------------------------------------------------------------------
            EXPERIMENTAL: Data structures for sparse tensors Coordinate (COO)
            format of sparse tensor index. COO's index list are represented as a
            NxM matrix, where N is the number of non-zero values, and M is the
            number of dimensions of a sparse tensor. indicesBuffer stores the
            location and size of the data of this indices matrix. The value type
            and the stride of the indices matrix is specified in indicesType and
            indicesStrides fields. For example, let X be a 2x3x4x5 tensor, and
            it has the following 6 non-zero values: ```text X[0, 1, 2, 0] := 1
            X[1, 1, 2, 3] := 2 X[0, 2, 1, 0] := 3 X[0, 1, 3, 0] := 4
            X[0, 1, 2, 1] := 5 X[1, 2, 0, 4] := 6 ``` In COO format, the index
            matrix of X is the following 4x6 matrix: ```text
            [[0, 0, 0, 0, 1, 1],    [1, 1, 1, 2, 1, 2],    [2, 2, 3, 1, 2, 0],  
             [0, 1, 0, 0, 3, 4]] ``` When isCanonical is true, the indices is
            sorted in lexicographical order (row-major order), and it does not
            have duplicated entries. Otherwise, the indices may not be sorted,
            or may have duplicated entries.

            Table org.apache.arrow.flatbuf.SparseTensorIndexCOO
            (//SparseTensor.fbs) *)
        and SparseTensorIndexCoo : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val indices_type : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Int.t) Rt.fb
          (** The type of values in indicesBuffer *)

          val indices_strides :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.Long.Vector.t) Rt.fbopt
          (** Non-negative byte offsets to advance one value cell along each
              dimension If omitted, default to row-major order (C-like). *)

          val indices_buffer :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.t) Rt.fb
          (** The location and size of the indices matrix's data *)

          val is_canonical : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** This flag is true if and only if the indices matrix is sorted in
              row-major order, and does not have duplicated entries. This sort
              order is the same as of Tensorflow's SparseTensor, but it is
              inverse order of SciPy's canonical coo_matrix (SciPy employs
              column-major order for its coo_matrix). *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> SparseTensorIndexCoo.t Rt.wip
            val add_indices_type : Int.t Rt.wip -> t -> t
            val add_indices_strides : Rt.Long.Vector.t Rt.wip -> t -> t
            val add_indices_buffer : Buffer.t -> t -> t
            val add_is_canonical : Rt.Bool.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.SparseTensor (//SparseTensor.fbs) *)
        and SparseTensor : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val type_type : 'b Rt.buf -> ('b, t) Rt.fb -> Type.t

          val type_ :
            ?none:'a ->
            ?null:(('b, Null.t) Rt.fb -> 'a) ->
            ?int:(('b, Int.t) Rt.fb -> 'a) ->
            ?floating_point:(('b, FloatingPoint.t) Rt.fb -> 'a) ->
            ?binary:(('b, Binary.t) Rt.fb -> 'a) ->
            ?utf8:(('b, Utf8.t) Rt.fb -> 'a) ->
            ?bool:(('b, Bool.t) Rt.fb -> 'a) ->
            ?decimal:(('b, Decimal.t) Rt.fb -> 'a) ->
            ?date:(('b, Date.t) Rt.fb -> 'a) ->
            ?time:(('b, Time.t) Rt.fb -> 'a) ->
            ?timestamp:(('b, Timestamp.t) Rt.fb -> 'a) ->
            ?interval:(('b, Interval.t) Rt.fb -> 'a) ->
            ?list:(('b, List.t) Rt.fb -> 'a) ->
            ?struct_:(('b, Struct_.t) Rt.fb -> 'a) ->
            ?union:(('b, Union.t) Rt.fb -> 'a) ->
            ?fixed_size_binary:(('b, FixedSizeBinary.t) Rt.fb -> 'a) ->
            ?fixed_size_list:(('b, FixedSizeList.t) Rt.fb -> 'a) ->
            ?map:(('b, Map.t) Rt.fb -> 'a) ->
            ?duration:(('b, Duration.t) Rt.fb -> 'a) ->
            ?large_binary:(('b, LargeBinary.t) Rt.fb -> 'a) ->
            ?large_utf8:(('b, LargeUtf8.t) Rt.fb -> 'a) ->
            ?large_list:(('b, LargeList.t) Rt.fb -> 'a) ->
            ?run_end_encoded:(('b, RunEndEncoded.t) Rt.fb -> 'a) ->
            ?binary_view:(('b, BinaryView.t) Rt.fb -> 'a) ->
            ?utf8_view:(('b, Utf8View.t) Rt.fb -> 'a) ->
            ?list_view:(('b, ListView.t) Rt.fb -> 'a) ->
            ?large_list_view:(('b, LargeListView.t) Rt.fb -> 'a) ->
            default:(Type.t -> 'a) ->
            'b Rt.buf ->
            ('b, t) Rt.fb ->
            'a
          (** The type of data contained in a value cell. Currently only
              fixed-width value types are supported, no strings or nested types.
          *)

          val shape :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, TensorDim.Vector.t) Rt.fb
          (** The dimensions of the tensor, optionally named. *)

          val non_zero_length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The number of non-zero values in a sparse tensor. *)

          val sparse_index_type :
            'b Rt.buf -> ('b, t) Rt.fb -> SparseTensorIndex.t

          val sparse_index :
            ?none:'a ->
            ?sparse_tensor_index_coo:(('b, SparseTensorIndexCoo.t) Rt.fb -> 'a) ->
            ?sparse_matrix_index_csx:(('b, SparseMatrixIndexCsx.t) Rt.fb -> 'a) ->
            ?sparse_tensor_index_csf:(('b, SparseTensorIndexCsf.t) Rt.fb -> 'a) ->
            default:(SparseTensorIndex.t -> 'a) ->
            'b Rt.buf ->
            ('b, t) Rt.fb ->
            'a
          (** Sparse tensor index *)

          val data : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.t) Rt.fb
          (** The location and size of the tensor's data *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> SparseTensor.t Rt.wip
            val add_type__null : Null.t Rt.wip -> t -> t
            val add_type__int : Int.t Rt.wip -> t -> t
            val add_type__floating_point : FloatingPoint.t Rt.wip -> t -> t
            val add_type__binary : Binary.t Rt.wip -> t -> t
            val add_type__utf8 : Utf8.t Rt.wip -> t -> t
            val add_type__bool : Bool.t Rt.wip -> t -> t
            val add_type__decimal : Decimal.t Rt.wip -> t -> t
            val add_type__date : Date.t Rt.wip -> t -> t
            val add_type__time : Time.t Rt.wip -> t -> t
            val add_type__timestamp : Timestamp.t Rt.wip -> t -> t
            val add_type__interval : Interval.t Rt.wip -> t -> t
            val add_type__list : List.t Rt.wip -> t -> t
            val add_type__struct_ : Struct_.t Rt.wip -> t -> t
            val add_type__union : Union.t Rt.wip -> t -> t
            val add_type__fixed_size_binary : FixedSizeBinary.t Rt.wip -> t -> t
            val add_type__fixed_size_list : FixedSizeList.t Rt.wip -> t -> t
            val add_type__map : Map.t Rt.wip -> t -> t
            val add_type__duration : Duration.t Rt.wip -> t -> t
            val add_type__large_binary : LargeBinary.t Rt.wip -> t -> t
            val add_type__large_utf8 : LargeUtf8.t Rt.wip -> t -> t
            val add_type__large_list : LargeList.t Rt.wip -> t -> t
            val add_type__run_end_encoded : RunEndEncoded.t Rt.wip -> t -> t
            val add_type__binary_view : BinaryView.t Rt.wip -> t -> t
            val add_type__utf8_view : Utf8View.t Rt.wip -> t -> t
            val add_type__list_view : ListView.t Rt.wip -> t -> t
            val add_type__large_list_view : LargeListView.t Rt.wip -> t -> t
            val add_shape : TensorDim.Vector.t Rt.wip -> t -> t
            val add_non_zero_length : Rt.Long.t -> t -> t

            val add_sparse_index_sparse_tensor_index_coo :
              SparseTensorIndexCoo.t Rt.wip -> t -> t

            val add_sparse_index_sparse_matrix_index_csx :
              SparseMatrixIndexCsx.t Rt.wip -> t -> t

            val add_sparse_index_sparse_tensor_index_csf :
              SparseTensorIndexCsf.t Rt.wip -> t -> t

            val add_data : Buffer.t -> t -> t
          end
        end

        (** Compressed Sparse format, that is matrix-specific.

            Table org.apache.arrow.flatbuf.SparseMatrixIndexCSX
            (//SparseTensor.fbs) *)
        and SparseMatrixIndexCsx : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val compressed_axis :
            'b Rt.buf -> ('b, t) Rt.fb -> SparseMatrixCompressedAxis.t
          (** Which axis, row or column, is compressed *)

          val indptr_type : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Int.t) Rt.fb
          (** The type of values in indptrBuffer *)

          val indptr_buffer : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.t) Rt.fb
          (** indptrBuffer stores the location and size of indptr array that
              represents the range of the rows. The i-th row spans from
              `indptr[i]` to `indptr[i+1]` in the data. The length of this array
              is 1 + (the number of rows), and the type of index value is long.
              For example, let X be the following 6x4 matrix: ```text X :=
              [[0, 1, 2, 0],         [0, 0, 3, 0],         [0, 4, 0, 5],        
               [0, 0, 0, 0],         [6, 0, 7, 8],         [0, 9, 0, 0]]. ```
              The array of non-zero values in X is: ```text values(X) =
              [1, 2, 3, 4, 5, 6, 7, 8, 9]. ``` And the indptr of X is: ```text
              indptr(X) = [0, 2, 3, 5, 5, 8, 10]. ``` *)

          val indices_type : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Int.t) Rt.fb
          (** The type of values in indicesBuffer *)

          val indices_buffer :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.t) Rt.fb
          (** indicesBuffer stores the location and size of the array that
              contains the column indices of the corresponding non-zero values.
              The type of index value is long. For example, the indices of the
              above X is: ```text indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1]. ```
              Note that the indices are sorted in lexicographical order for each
              row. *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> SparseMatrixIndexCsx.t Rt.wip
            val add_compressed_axis : SparseMatrixCompressedAxis.t -> t -> t
            val add_indptr_type : Int.t Rt.wip -> t -> t
            val add_indptr_buffer : Buffer.t -> t -> t
            val add_indices_type : Int.t Rt.wip -> t -> t
            val add_indices_buffer : Buffer.t -> t -> t
          end
        end

        (** ----------------------------------------------------------------------
            A Schema describes the columns in a row batch

            Table org.apache.arrow.flatbuf.Schema (//Schema.fbs) *)
        and Schema : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val endianness : 'b Rt.buf -> ('b, t) Rt.fb -> Endianness.t
          (** endianness of the buffer it is Little Endian by default if
              endianness doesn't match the underlying system then the vectors
              need to be converted *)

          val fields :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Field.Vector.t) Rt.fbopt

          val custom_metadata :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, KeyValue.Vector.t) Rt.fbopt

          val features :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Feature.Vector.t) Rt.fbopt
          (** Features used in the stream/file. *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Schema.t Rt.wip
            val add_endianness : Endianness.t -> t -> t
            val add_fields : Field.Vector.t Rt.wip -> t -> t
            val add_custom_metadata : KeyValue.Vector.t Rt.wip -> t -> t
            val add_features : Feature.Vector.t Rt.wip -> t -> t
          end
        end

        (** Contains two child arrays, run_ends and values. The run_ends child
            array must be a 16/32/64-bit integer array which encodes the indices
            at which the run with the value in each corresponding index in the
            values child array ends. Like list/struct types, the value array can
            be of any type.

            Table org.apache.arrow.flatbuf.RunEndEncoded (//Schema.fbs) *)
        and RunEndEncoded : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> RunEndEncoded.t Rt.wip
          end
        end

        (** A data header describing the shared memory layout of a "record" or
            "row" batch. Some systems call this a "row batch" internally and
            others a "record batch".

            Table org.apache.arrow.flatbuf.RecordBatch (//Message.fbs) *)
        and RecordBatch : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** number of records / rows. The arrays in the batch should all have
              this length *)

          val nodes :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, FieldNode.Vector.t) Rt.fbopt
          (** Nodes correspond to the pre-ordered flattened logical schema *)

          val buffers :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Buffer.Vector.t) Rt.fbopt
          (** Buffers correspond to the pre-ordered flattened buffer tree The
              number of buffers appended to this list depends on the schema. For
              example, most primitive arrays will have 2 buffers, 1 for the
              validity bitmap and 1 for the values. For struct arrays, there
              will only be a single buffer for the validity (nulls) bitmap *)

          val compression :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, BodyCompression.t) Rt.fbopt
          (** Optional compression of the message body *)

          val variadic_buffer_counts :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.Long.Vector.t) Rt.fbopt
          (** Some types such as Utf8View are represented using a variable
              number of buffers. For each such Field in the pre-ordered
              flattened logical schema, there will be an entry in
              variadicBufferCounts to indicate the number of number of variadic
              buffers which belong to that Field in the current RecordBatch. For
              example, the schema col1: Struct<alpha: Int32, beta: BinaryView,
              gamma: Float64> col2: Utf8View contains two Fields with variadic
              buffers so variadicBufferCounts will have two entries, the first
              counting the variadic buffers of `col1.beta` and the second
              counting `col2`'s. This field may be omitted if and only if the
              schema contains no Fields with a variable number of buffers, such
              as BinaryView and Utf8View. *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> RecordBatch.t Rt.wip
            val add_length : Rt.Long.t -> t -> t
            val add_nodes : FieldNode.Vector.t Rt.wip -> t -> t
            val add_buffers : Buffer.Vector.t Rt.wip -> t -> t
            val add_compression : BodyCompression.t Rt.wip -> t -> t
            val add_variadic_buffer_counts : Rt.Long.Vector.t Rt.wip -> t -> t
          end
        end

        (** These are stored in the flatbuffer in the Type union below

            Table org.apache.arrow.flatbuf.Null (//Schema.fbs) *)
        and Null : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Null.t Rt.wip
          end
        end

        (* Table org.apache.arrow.flatbuf.Message (//Message.fbs) *)
        and Message : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val extension : string option
          val identifier : string option

          val root :
            ?size_prefixed:bool ->
            ?off:int ->
            'b Flatbuffers.Primitives.t ->
            'b ->
            t Rt.root

          val finish_buf :
            ?size_prefixed:bool ->
            'a Flatbuffers.Primitives.t ->
            Rt.Builder.t ->
            t Rt.wip ->
            'a

          val version : 'b Rt.buf -> ('b, t) Rt.fb -> MetadataVersion.t
          val header_type : 'b Rt.buf -> ('b, t) Rt.fb -> MessageHeader.t

          val header :
            ?none:'a ->
            ?schema:(('b, Schema.t) Rt.fb -> 'a) ->
            ?dictionary_batch:(('b, DictionaryBatch.t) Rt.fb -> 'a) ->
            ?record_batch:(('b, RecordBatch.t) Rt.fb -> 'a) ->
            ?tensor:(('b, Tensor.t) Rt.fb -> 'a) ->
            ?sparse_tensor:(('b, SparseTensor.t) Rt.fb -> 'a) ->
            default:(MessageHeader.t -> 'a) ->
            'b Rt.buf ->
            ('b, t) Rt.fb ->
            'a

          val body_length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t

          val custom_metadata :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, KeyValue.Vector.t) Rt.fbopt

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Message.t Rt.wip
            val add_version : MetadataVersion.t -> t -> t
            val add_header_schema : Schema.t Rt.wip -> t -> t
            val add_header_dictionary_batch : DictionaryBatch.t Rt.wip -> t -> t
            val add_header_record_batch : RecordBatch.t Rt.wip -> t -> t
            val add_header_tensor : Tensor.t Rt.wip -> t -> t
            val add_header_sparse_tensor : SparseTensor.t Rt.wip -> t -> t
            val add_body_length : Rt.Long.t -> t -> t
            val add_custom_metadata : KeyValue.Vector.t Rt.wip -> t -> t
          end
        end

        (** A Map is a logical nested type that is represented as List<entries:
            Struct<key: K, value: V>> In this layout, the keys and values are
            each respectively contiguous. We do not constrain the key and value
            types, so the application is responsible for ensuring that the keys
            are hashable and unique. Whether the keys are sorted may be set in
            the metadata for this field. In a field with Map type, the field has
            a child Struct field, which then has two children: key type and the
            second the value type. The names of the child fields may be
            respectively "entries", "key", and "value", but this is not
            enforced. Map ```text - child[0] entries: Struct - child[0] key: K -
            child[1] value: V ``` Neither the "entries" field nor the "key"
            field may be nullable. The metadata is structured so that Arrow
            systems without special handling for Map can make Map an alias for
            List. The "layout" attribute for the Map field must have the same
            contents as a List.

            Table org.apache.arrow.flatbuf.Map (//Schema.fbs) *)
        and Map : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val keys_sorted : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** Set to true if the keys within each value are sorted *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Map.t Rt.wip
            val add_keys_sorted : Rt.Bool.t -> t -> t
          end
        end

        (** Represents the same logical types that List can, but contains
            offsets and sizes allowing for writes in any order and sharing of
            child values among list values.

            Table org.apache.arrow.flatbuf.ListView (//Schema.fbs) *)
        and ListView : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> ListView.t Rt.wip
          end
        end

        (* Table org.apache.arrow.flatbuf.List (//Schema.fbs) *)
        and List : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> List.t Rt.wip
          end
        end

        (** Same as Utf8, but with 64-bit offsets, allowing to represent
            extremely large data values.

            Table org.apache.arrow.flatbuf.LargeUtf8 (//Schema.fbs) *)
        and LargeUtf8 : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeUtf8.t Rt.wip
          end
        end

        (** Same as ListView, but with 64-bit offsets and sizes, allowing to
            represent extremely large data values.

            Table org.apache.arrow.flatbuf.LargeListView (//Schema.fbs) *)
        and LargeListView : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeListView.t Rt.wip
          end
        end

        (** Same as List, but with 64-bit offsets, allowing to represent
            extremely large data values.

            Table org.apache.arrow.flatbuf.LargeList (//Schema.fbs) *)
        and LargeList : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeList.t Rt.wip
          end
        end

        (** Same as Binary, but with 64-bit offsets, allowing to represent
            extremely large data values.

            Table org.apache.arrow.flatbuf.LargeBinary (//Schema.fbs) *)
        and LargeBinary : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> LargeBinary.t Rt.wip
          end
        end

        (** ----------------------------------------------------------------------
            user defined key value pairs to add custom metadata to arrow key
            namespacing is the responsibility of the user

            Table org.apache.arrow.flatbuf.KeyValue (//Schema.fbs) *)
        and KeyValue : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val key : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt
          val value : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> KeyValue.t Rt.wip
            val add_key : Rt.String.t Rt.wip -> t -> t
            val add_value : Rt.String.t Rt.wip -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.Interval (//Schema.fbs) *)
        and Interval : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> IntervalUnit.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Interval.t Rt.wip
            val add_unit : IntervalUnit.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.Int (//Schema.fbs) *)
        and Int : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val bit_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          val is_signed : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Int.t Rt.wip
            val add_bit_width : Rt.Int.t -> t -> t
            val add_is_signed : Rt.Bool.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.FloatingPoint (//Schema.fbs) *)
        and FloatingPoint : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val precision : 'b Rt.buf -> ('b, t) Rt.fb -> Precision.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> FloatingPoint.t Rt.wip
            val add_precision : Precision.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.FixedSizeList (//Schema.fbs) *)
        and FixedSizeList : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val list_size : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of list items per value *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> FixedSizeList.t Rt.wip
            val add_list_size : Rt.Int.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.FixedSizeBinary (//Schema.fbs) *)
        and FixedSizeBinary : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val byte_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of bytes per value *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> FixedSizeBinary.t Rt.wip
            val add_byte_width : Rt.Int.t -> t -> t
          end
        end

        (** ---------------------------------------------------------------------- Data structures for describing a table row batch (a collection of equal-length Arrow arrays) Metadata about a field at some level of a nested type tree (but not its children). For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]` would have {length: 5, null_count: 2} for its List node, and {length: 6, null_count: 0} for its Int16 node, as separate FieldNode structs

            Struct org.apache.arrow.flatbuf.FieldNode (//Message.fbs) *)
        and FieldNode : sig
          type t = Rt.Long.t * Rt.Long.t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t

          val length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The number of value slots in the Arrow array at this level of a
              nested tree *)

          val null_count : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The number of observed nulls. Fields with null_count == 0 may
              choose not to write their physical validity bitmap out as a
              materialized buffer, instead setting the length of the bitmap
              buffer to 0. *)
        end

        (** ----------------------------------------------------------------------
            A field represents a named column in a record / row batch or child
            of a nested type.

            Table org.apache.arrow.flatbuf.Field (//Schema.fbs) *)
        and Field : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val name : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Rt.String.t) Rt.fbopt
          (** Name is not required (e.g., in a List) *)

          val nullable : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** Whether or not this field can contain nulls. Should be true in
              general. *)

          val type_type : 'b Rt.buf -> ('b, t) Rt.fb -> Type.t

          val type_ :
            ?none:'a ->
            ?null:(('b, Null.t) Rt.fb -> 'a) ->
            ?int:(('b, Int.t) Rt.fb -> 'a) ->
            ?floating_point:(('b, FloatingPoint.t) Rt.fb -> 'a) ->
            ?binary:(('b, Binary.t) Rt.fb -> 'a) ->
            ?utf8:(('b, Utf8.t) Rt.fb -> 'a) ->
            ?bool:(('b, Bool.t) Rt.fb -> 'a) ->
            ?decimal:(('b, Decimal.t) Rt.fb -> 'a) ->
            ?date:(('b, Date.t) Rt.fb -> 'a) ->
            ?time:(('b, Time.t) Rt.fb -> 'a) ->
            ?timestamp:(('b, Timestamp.t) Rt.fb -> 'a) ->
            ?interval:(('b, Interval.t) Rt.fb -> 'a) ->
            ?list:(('b, List.t) Rt.fb -> 'a) ->
            ?struct_:(('b, Struct_.t) Rt.fb -> 'a) ->
            ?union:(('b, Union.t) Rt.fb -> 'a) ->
            ?fixed_size_binary:(('b, FixedSizeBinary.t) Rt.fb -> 'a) ->
            ?fixed_size_list:(('b, FixedSizeList.t) Rt.fb -> 'a) ->
            ?map:(('b, Map.t) Rt.fb -> 'a) ->
            ?duration:(('b, Duration.t) Rt.fb -> 'a) ->
            ?large_binary:(('b, LargeBinary.t) Rt.fb -> 'a) ->
            ?large_utf8:(('b, LargeUtf8.t) Rt.fb -> 'a) ->
            ?large_list:(('b, LargeList.t) Rt.fb -> 'a) ->
            ?run_end_encoded:(('b, RunEndEncoded.t) Rt.fb -> 'a) ->
            ?binary_view:(('b, BinaryView.t) Rt.fb -> 'a) ->
            ?utf8_view:(('b, Utf8View.t) Rt.fb -> 'a) ->
            ?list_view:(('b, ListView.t) Rt.fb -> 'a) ->
            ?large_list_view:(('b, LargeListView.t) Rt.fb -> 'a) ->
            default:(Type.t -> 'a) ->
            'b Rt.buf ->
            ('b, t) Rt.fb ->
            'a
          (** This is the type of the decoded value if the field is dictionary
              encoded. *)

          val dictionary :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, DictionaryEncoding.t) Rt.fbopt
          (** Present only if the field is dictionary encoded. *)

          val children : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Vector.t) Rt.fbopt
          (** children apply only to nested data types like Struct, List and
              Union. For primitive types children will have length 0. *)

          val custom_metadata :
            'b Rt.buf -> ('b, t) Rt.fb -> ('b, KeyValue.Vector.t) Rt.fbopt
          (** User-defined metadata *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Field.t Rt.wip
            val add_name : Rt.String.t Rt.wip -> t -> t
            val add_nullable : Rt.Bool.t -> t -> t
            val add_type__null : Null.t Rt.wip -> t -> t
            val add_type__int : Int.t Rt.wip -> t -> t
            val add_type__floating_point : FloatingPoint.t Rt.wip -> t -> t
            val add_type__binary : Binary.t Rt.wip -> t -> t
            val add_type__utf8 : Utf8.t Rt.wip -> t -> t
            val add_type__bool : Bool.t Rt.wip -> t -> t
            val add_type__decimal : Decimal.t Rt.wip -> t -> t
            val add_type__date : Date.t Rt.wip -> t -> t
            val add_type__time : Time.t Rt.wip -> t -> t
            val add_type__timestamp : Timestamp.t Rt.wip -> t -> t
            val add_type__interval : Interval.t Rt.wip -> t -> t
            val add_type__list : List.t Rt.wip -> t -> t
            val add_type__struct_ : Struct_.t Rt.wip -> t -> t
            val add_type__union : Union.t Rt.wip -> t -> t
            val add_type__fixed_size_binary : FixedSizeBinary.t Rt.wip -> t -> t
            val add_type__fixed_size_list : FixedSizeList.t Rt.wip -> t -> t
            val add_type__map : Map.t Rt.wip -> t -> t
            val add_type__duration : Duration.t Rt.wip -> t -> t
            val add_type__large_binary : LargeBinary.t Rt.wip -> t -> t
            val add_type__large_utf8 : LargeUtf8.t Rt.wip -> t -> t
            val add_type__large_list : LargeList.t Rt.wip -> t -> t
            val add_type__run_end_encoded : RunEndEncoded.t Rt.wip -> t -> t
            val add_type__binary_view : BinaryView.t Rt.wip -> t -> t
            val add_type__utf8_view : Utf8View.t Rt.wip -> t -> t
            val add_type__list_view : ListView.t Rt.wip -> t -> t
            val add_type__large_list_view : LargeListView.t Rt.wip -> t -> t
            val add_dictionary : DictionaryEncoding.t Rt.wip -> t -> t
            val add_children : Field.Vector.t Rt.wip -> t -> t
            val add_custom_metadata : KeyValue.Vector.t Rt.wip -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.Duration (//Schema.fbs) *)
        and Duration : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> TimeUnit.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Duration.t Rt.wip
            val add_unit : TimeUnit.t -> t -> t
          end
        end

        (* Table org.apache.arrow.flatbuf.DictionaryEncoding (//Schema.fbs) *)
        and DictionaryEncoding : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val id : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The known dictionary id in the application where this data is
              used. In the file or streaming formats, the dictionary ids are
              found in the DictionaryBatch messages *)

          val index_type : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, Int.t) Rt.fbopt
          (** The dictionary indices are constrained to be non-negative
              integers. If this field is null, the indices must be signed int32.
              To maximize cross-language compatibility and performance,
              implementations are recommended to prefer signed integer types
              over unsigned integer types and to avoid uint64 indices unless
              they are required by an application. *)

          val is_ordered : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** By default, dictionaries are not ordered, or the order does not
              have semantic meaning. In some statistical, applications,
              dictionary-encoding is used to represent ordered categorical data,
              and we provide a way to preserve that metadata here *)

          val dictionary_kind : 'b Rt.buf -> ('b, t) Rt.fb -> DictionaryKind.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> DictionaryEncoding.t Rt.wip
            val add_id : Rt.Long.t -> t -> t
            val add_index_type : Int.t Rt.wip -> t -> t
            val add_is_ordered : Rt.Bool.t -> t -> t
            val add_dictionary_kind : DictionaryKind.t -> t -> t
          end
        end

        (** For sending dictionary encoding information. Any Field can be
            dictionary-encoded, but in this case none of its children may be
            dictionary-encoded. There is one vector / column per dictionary, but
            that vector / column may be spread across multiple dictionary
            batches by using the isDelta flag

            Table org.apache.arrow.flatbuf.DictionaryBatch (//Message.fbs) *)
        and DictionaryBatch : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val id : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          val data : 'b Rt.buf -> ('b, t) Rt.fb -> ('b, RecordBatch.t) Rt.fbopt

          val is_delta : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Bool.t
          (** If isDelta is true the values in the dictionary are to be appended
              to a dictionary with the indicated id. If isDelta is false this
              dictionary should replace the existing dictionary. *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> DictionaryBatch.t Rt.wip
            val add_id : Rt.Long.t -> t -> t
            val add_data : RecordBatch.t Rt.wip -> t -> t
            val add_is_delta : Rt.Bool.t -> t -> t
          end
        end

        (** Exact decimal value represented as an integer value in two's
            complement. Currently 32-bit (4-byte), 64-bit (8-byte), 128-bit
            (16-byte) and 256-bit (32-byte) integers are used. The
            representation uses the endianness indicated in the Schema.

            Table org.apache.arrow.flatbuf.Decimal (//Schema.fbs) *)
        and Decimal : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val precision : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Total number of decimal digits *)

          val scale : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of digits after the decimal point "." *)

          val bit_width : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Int.t
          (** Number of bits per value. The accepted widths are 32, 64, 128 and
              256. We use bitWidth for consistency with Int::bitWidth. *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Decimal.t Rt.wip
            val add_precision : Rt.Int.t -> t -> t
            val add_scale : Rt.Int.t -> t -> t
            val add_bit_width : Rt.Int.t -> t -> t
          end
        end

        (** Date is either a 32-bit or 64-bit signed integer type representing
            an elapsed time since UNIX epoch (1970-01-01), stored in either of
            two units: * Milliseconds (64 bits) indicating UNIX time elapsed
            since the epoch (no leap seconds), where the values are evenly
            divisible by 86400000 * Days (32 bits) since the UNIX epoch

            Table org.apache.arrow.flatbuf.Date (//Schema.fbs) *)
        and Date : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val unit : 'b Rt.buf -> ('b, t) Rt.fb -> DateUnit.t

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Date.t Rt.wip
            val add_unit : DateUnit.t -> t -> t
          end
        end

        (** ----------------------------------------------------------------------
            A Buffer represents a single contiguous memory segment

            Struct org.apache.arrow.flatbuf.Buffer (//Schema.fbs) *)
        and Buffer : sig
          type t = Rt.Long.t * Rt.Long.t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t

          val offset : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The relative offset into the shared memory page where the bytes
              for this buffer starts *)

          val length : 'b Rt.buf -> ('b, t) Rt.fb -> Rt.Long.t
          (** The absolute length (in bytes) of the memory buffer. The memory is
              found from offset (inclusive) to offset + length (non-inclusive).
              When building messages using the encapsulated IPC message, padding
              bytes may be written after a buffer, but such padding bytes do not
              need to be accounted for in the size here. *)
        end

        (* Table org.apache.arrow.flatbuf.Bool (//Schema.fbs) *)
        and Bool : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Bool.t Rt.wip
          end
        end

        (** Optional compression for the memory buffers constituting IPC message
            bodies. Intended for use with RecordBatch but could be used for
            other message types

            Table org.apache.arrow.flatbuf.BodyCompression (//Message.fbs) *)
        and BodyCompression : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          val codec : 'b Rt.buf -> ('b, t) Rt.fb -> CompressionType.t
          (** Compressor library. For LZ4_FRAME, each compressed buffer must
              consist of a single frame. *)

          val method_ : 'b Rt.buf -> ('b, t) Rt.fb -> BodyCompressionMethod.t
          (** Indicates the way the record batch body was compressed *)

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> BodyCompression.t Rt.wip
            val add_codec : CompressionType.t -> t -> t
            val add_method_ : BodyCompressionMethod.t -> t -> t
          end
        end

        (** Logically the same as Binary, but the internal representation uses a
            view struct that contains the string length and either the string's
            entire data inline (for small strings) or an inlined prefix, an
            index of another buffer, and an offset pointing to a slice in that
            buffer (for non-small strings). Since it uses a variable number of
            data buffers, each Field with this type must have a corresponding
            entry in `variadicBufferCounts`.

            Table org.apache.arrow.flatbuf.BinaryView (//Schema.fbs) *)
        and BinaryView : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> BinaryView.t Rt.wip
          end
        end

        (** Opaque binary data

            Table org.apache.arrow.flatbuf.Binary (//Schema.fbs) *)
        and Binary : sig
          type t

          module Vector :
            Rt.VectorS
              with type 'b elt := ('b, t) Rt.fb
               and type builder_elt := t Rt.wip

          module Builder : sig
            type t

            val start : Rt.Builder.t -> t
            val finish : t -> Binary.t Rt.wip
          end
        end
      end
      (* Flatbuf *)
    end
    (* Arrow *)
  end
  (* Apache *)
end
(* Org *)
